/*------------------------------------------------------------------------------
  09/11/2021
  Author: Mahmoud Kotb 
  Board: NODMCU - ESP32S
  Language: C++/Arduino
  File: GPS_DataLogger.ino
  ------------------------------------------------------------------------------
  Description: 
  A GPS Data Logger which send the data to an end point server
  ------------------------------------------------------------------------------
  License:
  
------------------------------------------------------------------------------*/


//Libraries for NEO-M8N GPS Module
#include <TinyGPSPlus.h>
#include <SoftwareSerial.h>

//Libraries for MPU9250
#include <MPU9250_asukiaaa.h>
#ifdef _ESP32_HAL_I2C_H_
#define SDA_PIN 21
#define SCL_PIN 22
#endif

//Libraries for SD Card
#include "FS.h"
#include "SD.h"
#include "SPI.h"

// Libraries for WIFI
#include <WiFi.h>
#include <time.h> 

//Libraries for OLED Display
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

//GPS Data
static const int RXPin = 25, TXPin = 26;
static const uint32_t GPSBaud = 9600;
// The TinyGPSPlus object
TinyGPSPlus gps;
// The serial connection to the GPS device
SoftwareSerial ss(RXPin, TXPin);

//MPU9250 Data
MPU9250_asukiaaa mySensor;
float aX, aY, aZ, aSqrt, gX, gY, gZ, mDirection, mX, mY, mZ;


//WIFI Data
const char* ssid     = "HussieN";
const char* password = "Hessen2002";

//OLED Data
Adafruit_SSD1306 display(128, 64, &Wire, -1);
// Bitmap of QSIT Image
const unsigned char QSIT [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x70, 0xe5, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x03, 0xc1, 0xed, 0xf8, 0x00, 0x1f, 0xff, 0xcf, 0xf7, 0xff, 0xff, 0xf0, 0x00, 0x00, 
  0x00, 0x00, 0x0f, 0x03, 0xe0, 0xfc, 0x00, 0xff, 0xff, 0xcf, 0xf7, 0xff, 0xff, 0xf0, 0x00, 0x00, 
  0x00, 0x00, 0x1e, 0x06, 0xc7, 0x1e, 0x01, 0xff, 0xff, 0xcf, 0xf7, 0xff, 0xff, 0xf0, 0x00, 0x00, 
  0x00, 0x00, 0x3c, 0x06, 0x7e, 0x0f, 0x03, 0xff, 0xff, 0xcf, 0xf7, 0xff, 0xff, 0xf0, 0x00, 0x00, 
  0x00, 0x00, 0x78, 0x0d, 0xfe, 0x0f, 0x07, 0xff, 0xff, 0xcf, 0xf7, 0xff, 0xff, 0xf0, 0x00, 0x00, 
  0x00, 0x00, 0x78, 0x0f, 0xee, 0x0f, 0x87, 0xff, 0xff, 0xc0, 0x03, 0xff, 0xff, 0xe0, 0x00, 0x00, 
  0x00, 0x00, 0xf0, 0x1e, 0xce, 0x07, 0x8f, 0xf8, 0x00, 0x00, 0x00, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xf0, 0x1e, 0xf8, 0x07, 0xcf, 0xf8, 0x00, 0x0f, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xf0, 0x1e, 0x20, 0x03, 0xcf, 0xfc, 0x00, 0x0f, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x01, 0xe0, 0x1f, 0x00, 0x63, 0xcf, 0xff, 0x00, 0x0f, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x01, 0xe0, 0x10, 0x00, 0x33, 0xc7, 0xff, 0xe0, 0x0f, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xe0, 0x10, 0x00, 0x1f, 0xc7, 0xff, 0xf8, 0x0f, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xf0, 0x10, 0x00, 0x0f, 0xc3, 0xff, 0xfe, 0x0f, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xf0, 0x10, 0x00, 0x07, 0xc0, 0xff, 0xff, 0x0f, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xf0, 0x18, 0x38, 0x07, 0x80, 0x3f, 0xff, 0x8f, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x78, 0x1c, 0xfd, 0x07, 0x80, 0x0f, 0xff, 0x8f, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x38, 0x1e, 0xf8, 0x0f, 0x00, 0x01, 0xff, 0xcf, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x3c, 0x0e, 0xf8, 0x1f, 0x00, 0x00, 0x7f, 0xcf, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x0e, 0x0c, 0xf4, 0x1e, 0x00, 0x00, 0x7f, 0xcf, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x07, 0x06, 0x03, 0xfc, 0x06, 0x00, 0x7f, 0xcf, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0xc7, 0x73, 0xf8, 0x07, 0xf1, 0xff, 0x8f, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x03, 0x3b, 0xe0, 0x07, 0xff, 0xff, 0x8f, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x01, 0xff, 0x80, 0x0f, 0xff, 0xff, 0x0f, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x03, 0xf8, 0xfe, 0x00, 0x0f, 0xff, 0xfe, 0x0f, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x0f, 0xff, 0xfc, 0x0f, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x3f, 0xff, 0xff, 0x00, 0x07, 0xff, 0xf0, 0x0f, 0xf0, 0x0f, 0xf8, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xe0, 0x1f, 0xfc, 0x00, 0x00, 0x3e, 0x00, 0x0f, 0xf0, 0x07, 0xf0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

void setup()
{
  Serial.begin(115200);
  
  //Information and data for the SD Card
  Serial.println();
  if(!SD.begin()){
    Serial.println("Card Mount Failed");
    return;
  }
  uint8_t cardType = SD.cardType();
  if(cardType == CARD_NONE){
    Serial.println("No SD card attached");
    return;
  }
  Serial.print("SD Card Type: ");
  if(cardType == CARD_MMC){
    Serial.println("MMC");
    } else if(cardType == CARD_SD){
    Serial.println("SDSC");
    } else if(cardType == CARD_SDHC){
    Serial.println("SDHC");
    } else {
    Serial.println("UNKNOWN");
  }
  uint64_t cardSize = SD.cardSize() / (1024 * 1024);
  Serial.printf("SD Card Size: %lluMB\n", cardSize);
    
  // Connecting to a WiFi network
  Serial.println();
  Serial.print("Connecting to ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("WiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
  Serial.println();
  
  //Start Reading GPS Data
  ss.begin(GPSBaud);
  Serial.println(F("Sats,HDOP,Latitude,Longitude,Date,Time,accelX,accelY,accelZ,accelSqrt,gyroX,gyroY,gyroZ,magX,magY,magZ,H-direction"));
  Serial.println(F("----,----,--------,---------,----,----,------,------,------,---------,-----,-----,-----,----,----,----,-----------"));

  //Definition of I2C for the MPU9250
  #ifdef _ESP32_HAL_I2C_H_ // For ESP32
  Wire.begin(SDA_PIN, SCL_PIN);
  mySensor.setWire(&Wire);
  #endif
  //Start Reading MPU9250 Data
  mySensor.beginAccel();
  mySensor.beginGyro();
  mySensor.beginMag();

  // initialize with the I2C addr 0x3C of OLED Display
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);  
  // Clear the buffer.
  display.clearDisplay();
  // Display bitmap
  display.drawBitmap(0, 0,  QSIT, 128, 64, WHITE);
  display.display();
  // Invert Display
  //display.invertDisplay(1);
  
  }

void loop()
{
  //Print of the GPS Data
  printInt(gps.satellites.value(), gps.satellites.isValid(),2);
  Serial.print(",");
  printFloat(gps.hdop.hdop(), gps.hdop.isValid(), 6, 1);
  Serial.print(",");
  printFloat(gps.location.lat(), gps.location.isValid(), 11, 6);
  Serial.print(",");
  printFloat(gps.location.lng(), gps.location.isValid(), 12, 6);
  Serial.print(",");
  printDateTime(gps.date, gps.time);
  Serial.print(",");

  //Print of the MPU9250 Data
  printAccel();
  printGyro();
  printMag();
  Serial.println();
  
  smartDelay(100);

  if (millis() > 5000 && gps.charsProcessed() < 10)
    Serial.println(F("No GPS data received: check wiring"));
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// This custom version of delay() ensures that the gps object
// is being "fed".
static void smartDelay(unsigned long ms)
{
  unsigned long start = millis();
  do 
  {
    while (ss.available())
      gps.encode(ss.read());
  } while (millis() - start < ms);
}

//Function for printing Float for GPS Data
static void printFloat(float val, bool valid, int len, int prec)
{
  if (!valid)
  {
    while (len-- > 1)
      Serial.print('*');
    Serial.print(' ');
  }
  else
  {
    Serial.print(val, prec);
    int vi = abs((int)val);
    int flen = prec + (val < 0.0 ? 2 : 1); // . and -
    flen += vi >= 1000 ? 4 : vi >= 100 ? 3 : vi >= 10 ? 2 : 1;
    for (int i=flen; i<len; ++i)
      Serial.print(' ');
  }
  smartDelay(0);
}

//Function for printing Int for GPS Data
static void printInt(unsigned long val, bool valid, int len)
{
  char sz[32] = "*****************";
  if (valid)
    sprintf(sz, "%ld", val);
  sz[len] = 0;
  for (int i=strlen(sz); i<len; ++i)
    sz[i] = ' ';
  if (len > 0) 
    sz[len-1] = ' ';
  Serial.print(sz);
  smartDelay(0);
}

//Function for printing Date & Time for GPS Data
static void printDateTime(TinyGPSDate &d, TinyGPSTime &t)
{
  if (!d.isValid())
  {
    Serial.print(F("********** "));
  }
  else
  {
    char sz[32];
    sprintf(sz, "%02d/%02d/%02d ", d.month(), d.day(), d.year());
    Serial.print(sz);
  }
  Serial.print(",");
  if (!t.isValid())
  {
    Serial.print(F("******** "));
  }
  else
  {
    char sz[32];
    sprintf(sz, "%02d:%02d:%02d ", t.hour(), t.minute(), t.second());
    Serial.print(sz);
  }
  
  smartDelay(0);
}

//Function for printing stars for Null GPS Data
static void printStr(const char *str, int len)
{
  int slen = strlen(str);
  for (int i=0; i<len; ++i)
    Serial.print(i<slen ? str[i] : ' ');
  smartDelay(0);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static void printAccel(){
  if (mySensor.accelUpdate() == 0) {
    aX = mySensor.accelX();
    aY = mySensor.accelY();
    aZ = mySensor.accelZ();
    aSqrt = mySensor.accelSqrt();
    Serial.print(String(aX));
    Serial.print(",");
    Serial.print(String(aY));
    Serial.print(",");
    Serial.print(String(aZ));
    Serial.print(",");
    Serial.print(String(aSqrt));
    Serial.print(",");
  } else {
    Serial.println("Cannod read accel values");
  }
}
static void printGyro(){
  if (mySensor.gyroUpdate() == 0) {
    gX = mySensor.gyroX();
    gY = mySensor.gyroY();
    gZ = mySensor.gyroZ();
    Serial.print(String(gX));
    Serial.print(",");
    Serial.print(String(gY));
    Serial.print(",");
    Serial.print(String(gZ));
    Serial.print(",");
  } else {
    Serial.println("Cannot read gyro values");
  }
}

static void printMag(){
  if (mySensor.magUpdate() == 0) {
    mX = mySensor.magX();
    mY = mySensor.magY();
    mZ = mySensor.magZ();
    mDirection = mySensor.magHorizDirection();
    Serial.print(String(mX));
    Serial.print(",");
    Serial.print(String(mY));
    Serial.print(",");
    Serial.print(String(mZ));
    Serial.print(",");
    Serial.print(String(mDirection));
    Serial.print(",");
  } else {
    Serial.println("Cannot read mag values");
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void listDir(fs::FS &fs, const char * dirname, uint8_t levels){
    Serial.printf("Listing directory: %s\n", dirname);

    File root = fs.open(dirname);
    if(!root){
        Serial.println("Failed to open directory");
        return;
    }
    if(!root.isDirectory()){
        Serial.println("Not a directory");
        return;
    }

    File file = root.openNextFile();
    while(file){
        if(file.isDirectory()){
            Serial.print("  DIR : ");
            Serial.println(file.name());
            if(levels){
                listDir(fs, file.path(), levels -1);
            }
        } else {
            Serial.print("  FILE: ");
            Serial.print(file.name());
            Serial.print("  SIZE: ");
            Serial.println(file.size());
        }
        file = root.openNextFile();
    }
}

void createDir(fs::FS &fs, const char * path){
    Serial.printf("Creating Dir: %s\n", path);
    if(fs.mkdir(path)){
        Serial.println("Dir created");
    } else {
        Serial.println("mkdir failed");
    }
}

void removeDir(fs::FS &fs, const char * path){
    Serial.printf("Removing Dir: %s\n", path);
    if(fs.rmdir(path)){
        Serial.println("Dir removed");
    } else {
        Serial.println("rmdir failed");
    }
}

void readFile(fs::FS &fs, const char * path){
    Serial.printf("Reading file: %s\n", path);

    File file = fs.open(path);
    if(!file){
        Serial.println("Failed to open file for reading");
        return;
    }

    Serial.print("Read from file: ");
    while(file.available()){
        Serial.write(file.read());
    }
    file.close();
}

void writeFile(fs::FS &fs, const char * path, const char * message){
    Serial.printf("Writing file: %s\n", path);

    File file = fs.open(path, FILE_WRITE);
    if(!file){
        Serial.println("Failed to open file for writing");
        return;
    }
    if(file.print(message)){
        Serial.println("File written");
    } else {
        Serial.println("Write failed");
    }
    file.close();
}

void appendFile(fs::FS &fs, const char * path, const char * message){
    Serial.printf("Appending to file: %s\n", path);

    File file = fs.open(path, FILE_APPEND);
    if(!file){
        Serial.println("Failed to open file for appending");
        return;
    }
    if(file.print(message)){
        Serial.println("Message appended");
    } else {
        Serial.println("Append failed");
    }
    file.close();
}

void renameFile(fs::FS &fs, const char * path1, const char * path2){
    Serial.printf("Renaming file %s to %s\n", path1, path2);
    if (fs.rename(path1, path2)) {
        Serial.println("File renamed");
    } else {
        Serial.println("Rename failed");
    }
}

void deleteFile(fs::FS &fs, const char * path){
    Serial.printf("Deleting file: %s\n", path);
    if(fs.remove(path)){
        Serial.println("File deleted");
    } else {
        Serial.println("Delete failed");
    }
}

void testFileIO(fs::FS &fs, const char * path){
    File file = fs.open(path);
    static uint8_t buf[512];
    size_t len = 0;
    uint32_t start = millis();
    uint32_t end = start;
    if(file){
        len = file.size();
        size_t flen = len;
        start = millis();
        while(len){
            size_t toRead = len;
            if(toRead > 512){
                toRead = 512;
            }
            file.read(buf, toRead);
            len -= toRead;
        }
        end = millis() - start;
        Serial.printf("%u bytes read for %u ms\n", flen, end);
        file.close();
    } else {
        Serial.println("Failed to open file for reading");
    }


    file = fs.open(path, FILE_WRITE);
    if(!file){
        Serial.println("Failed to open file for writing");
        return;
    }

    size_t i;
    start = millis();
    for(i=0; i<2048; i++){
        file.write(buf, 512);
    }
    end = millis() - start;
    Serial.printf("%u bytes written for %u ms\n", 2048 * 512, end);
    file.close();
}
